
/* [bake me]

dependencies["headers"] = [
	"util>>headers"
]

[stop baking] */

#pragma once

#include "yorel/multi_methods.hpp"

#include "util/util.hpp"

namespace si {

// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// WARNING Always call MM_INIT() in every constructor!     WARNING
// WARNING DO NOT RELY ON SYNTHESIZED CONSTRUCTORS!        WARNING
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING

// Disadvantage of yomm11: verbose constructors
// I am more than willing to pay that price though

#define SIMPLE_CTORS(classname)     \
classname() {                       \
  MM_INIT();                        \
}                                   \
classname(const classname& c) {     \
  MM_INIT();                        \
}


// Event cooperates with yomm11
class Event: public yorel::multi_methods::selector {
public:
	MM_CLASS(Event);
	
	SIMPLE_CTORS(Event);
	
	virtual Event* clone() = 0;
};


namespace model {
	// forward declaration
	class Entity;
}


#define SIMPLE_EVENT(name)      \
class name: public Event {             \
public:                               \
	MM_CLASS(name, Event);             \
	SIMPLE_CTORS(name);               \
	Event* clone() {                  \
		return new name(*this);       \
	}                                 \
};



// Events below are given in the order they will most likely be spawned

SIMPLE_EVENT(Init);

SIMPLE_EVENT(GameStart);

SIMPLE_EVENT(WaitPlayers);

class PlayerEvent: public Event {
public:
	MM_CLASS(PlayerEvent, Event);
	
	PlayerEvent(unsigned int _ID):
			ID(_ID) {
		MM_INIT();
	}
	
	PlayerEvent(const PlayerEvent& p):
			ID(p.ID) {
		MM_INIT();
	}
	
	unsigned int ID;
};

#define PLAYER_EVENT(name)       \
class name: public PlayerEvent { \
public: \
	MM_CLASS(name, PlayerEvent);\
	name(unsigned int _ID):\
			PlayerEvent(_ID) {\
		MM_INIT();\
	}\
	name(const name& n):\
			PlayerEvent(n) {\
		MM_INIT();\
	}\
};

PLAYER_EVENT(CreatePlayer);

PLAYER_EVENT(ReleasePlayer);

class SetDirection: public PlayerEvent {
public: 
	MM_CLASS(SetDirection, PlayerEvent);
	SetDirection(unsigned int _ID, si::util::Vector2D_d _dir):
			PlayerEvent(_ID), dir(_dir) {
		MM_INIT();
	}
	
	SetDirection(const SetDirection& n):
			PlayerEvent(n), dir(n.dir) {
		MM_INIT();
	}
	
	si::util::Vector2D_d dir;
};


SIMPLE_EVENT(Ready);

SIMPLE_EVENT(LevelStart);

// Has a more special status in some contexts
// Basically, all events are in someway generated by user input. However, a Tick event can be
// spawned independently from user input. This is important because Ticks may flood the
// communication channels in multithreaded environments.
// If there were more events like these, I would subclass them from Tick (and possibly
// rename Tick). However, so far that has not been necessary.
SIMPLE_EVENT(Tick);

SIMPLE_EVENT(LevelEnd);

SIMPLE_EVENT(Recap);

SIMPLE_EVENT(Victory);

SIMPLE_EVENT(Failure);

SIMPLE_EVENT(GameStop);

SIMPLE_EVENT(Quit);

// don't like macro's?
#undef SIMPLE_EVENT
#undef PLAYER_EVENT
#undef SIMPLE_CTORS

// Above are all the definitions of all the possible subclasses of Event, technically.
// However, you could argue (and this is also how I originally imagined it) that there
// are also implicit events within the open multimethods in model. These implicit Events
// are never instantiated, but are immediatly handled in some onFoo(Bar) function.
// An example is: TODO

}
